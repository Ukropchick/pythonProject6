"""

 * Объединить два ассоциативных массива `dict_a` и `dict_b` с парами
 * "имя"-"номер телефона" в итоговый ассоциативный массив, склеивая
 * значения для повторяющихся ключей через запятую.
 * В случае повторяющихся *ключей* значение из dict_a должно быть
 * перед значением из dict_b.
 *
 * Повторяющиеся *значения* следует добавлять только один раз.
 *
 * Например:
 *   merge_phone_books(
 *     {"Emergency": "112", "Police": "02"},
 *     {"Emergency": "911", "Police": "02"}
 *   ) -> {"Emergency": "112, 911", "Police": "02"}

"""


def merge_phone_books(dict_a: dict, dict_b: dict) -> dict:
    """TODO"""


"""

 * Входными данными является ассоциативный массив
 * "название товара"-"пара (тип товара, цена товара)"
 * и тип интересующего нас товара.
 * Необходимо вернуть название товара заданного типа с минимальной стоимостью
 * или None в случае, если товаров такого типа нет.
 *
 * Например:
 *   find_cheapest_stuff(
 *     {"Мария": ("печенье" to 20.0), "Орео": ("печенье" to 100.0)),
 *     "печенье"
 *   ) -> "Мария"

"""


def find_cheapest_stuff(stuff: dict, kind: str) -> str:
    """TODO"""


"""

 * Найти в заданном списке повторяющиеся элементы и вернуть
 * ассоциативный массив с информацией о числе повторений
 * для каждого повторяющегося элемента.
 * Если элемент встречается только один раз, включать его в результат
 * не следует.

 Например:
 *   extract_repeats(["a", "b", "a"] -> {"a": 2}
 
"""


def extract_repeats(input_list: list) -> dict:
    """TODO"""
